import numpy as np
import matplotlib.pyplot as plt
from numba import njit


@njit
def golomb_grow(n: int) -> np.ndarray:
    """
    Generates the first n Golomb rulers using an optimized growing algorithm.
    """
    G = np.zeros(n, dtype=np.int64)
    # D will store whether a difference has been seen. Use a larger initial size.
    D_size = 1024
    D = np.zeros(D_size, dtype=np.bool_)

    G[0] = 0
    current_length = 1

    while current_length < n:
        # Start checking from the next integer after the last element
        m = G[current_length - 1] + 1

        while True:
            valid = True
            max_diff = 0

            # Check if current m creates any repeated differences with existing G elements
            for i in range(current_length):
                diff = m - G[i]

                # Dynamically resize D if a new difference exceeds its current bounds
                if diff >= D_size:
                    # Double size or just enough + 1
                    new_size = max(D_size * 2, diff + 1)
                    new_D = np.zeros(new_size, dtype=np.bool_)
                    new_D[:D_size] = D  # Copy old values
                    D = new_D
                    D_size = new_size

                if D[diff]:  # If this difference already exists
                    valid = False
                    break
                if diff > max_diff:
                    max_diff = diff

            if valid:
                # Secondary check using a temporary array for differences generated by *this* m.
                # This ensures that m itself doesn't create internal duplicates among its *new* differences.
                temp = np.zeros(max_diff + 1, dtype=np.bool_)
                for i in range(current_length):
                    diff = m - G[i]
                    if temp[diff]:  # Check for duplicates among the *new* differences formed by m
                        valid = False
                        break
                    temp[diff] = True

            if valid:
                # If m is valid, add its new differences to the global D set
                for i in range(current_length):
                    diff = m - G[i]
                    D[diff] = True
                G[current_length] = m  # Add m to the Golomb ruler
                current_length += 1
                break  # Move to find the next element in the ruler
            else:
                m += 1  # Increment m and try again

    return G


def create_signal_from_golomb(G: np.ndarray, remove_dc: bool) -> np.ndarray:
    """
    Creates a binary signal from a Golomb ruler, with optional DC removal.
    The signal length is G[-1] + 1, and 1s are placed at Golomb indices.
    """
    signal = np.zeros(G[-1] + 1)
    signal[G] = 1
    if remove_dc:
        signal -= np.mean(signal)  # Remove DC component (mean subtraction)

    # Normalize by the maximum absolute value to keep amplitude within [-1, 1]
    max_amp = np.max(np.abs(signal))
    # Avoid division by zero if signal is all zeros (unlikely here)
    if max_amp > 1e-10:
        signal /= max_amp

    return signal


# Modified to accept windowing parameters
def compute_spectrum(signal: np.ndarray, apply_window: bool, window_type: str):
    """
    Computes the FFT, magnitude spectrum, and power spectrum of a signal.
    Includes print statements for DC components for debugging.
    Applies a specified window function if apply_window is True.
    """
    print(f"Value of signal mean BEFORE FFT: {np.mean(signal)}")

    # Start with a copy to avoid modifying original 'signal'
    windowed_signal = signal.copy()

    if apply_window:
        # Dictionary to map window names to numpy window functions
        windows = {
            'hanning': np.hanning,
            'hamming': np.hamming,
            'blackman': np.blackman,
            # Rectangular window is just ones
            'rectangular': lambda N: np.ones(N)
        }

        if window_type.lower() in windows:
            window_func = windows[window_type.lower()]
            windowed_signal *= window_func(len(signal))
            print(f"--- Applied {window_type} window ---")
        else:
            print(
                f"Warning: Unknown window type '{window_type}'. Using rectangular window.")
            # If an unknown type is given, it will effectively use rectangular (no window applied)
            # The 'windowing_applied' flag passed to plot_results will still be True,
            # but the plot title will reflect the 'unknown' name unless handled.
            # For simplicity, we just apply no window here, and the plot_results
            # should clarify based on the original 'windowing' flag.
    else:
        print("--- No windowing applied (rectangular implicitly) ---")

    X = np.fft.fft(windowed_signal)  # Use windowed_signal here

    freqs = np.fft.fftfreq(len(X))
    mag = np.abs(X)
    power = mag ** 2

    print(f"Magnitude of DC component (mag[0]): {mag[0]}")
    print(f"Power of DC component (power[0]): {power[0]}")

    return freqs, mag, power


def plot_results(signal: np.ndarray, freqs: np.ndarray, mag: np.ndarray, power: np.ndarray,
                 n: int, remove_dc_flag: bool, windowing_applied: bool, window_name: str):
    """
    Plots the time-domain signal, FFT magnitude spectrum, and power spectrum.
    """
    if remove_dc_flag:
        idx = (freqs > 0) & (freqs <= 0.5)
        dc_status_text = " (DC removed from time signal)"
    else:
        idx = (freqs >= 0) & (freqs <= 0.5)
        dc_status_text = " (DC Kept)"

    if windowing_applied:
        window_status_text = f" ({window_name.capitalize()} Window)"
    else:
        window_status_text = " (No Explicit Window)"

    freqs = freqs[idx]
    mag = mag[idx]
    power = power[idx]
    time_indices = np.arange(len(signal))

    fig = plt.figure(figsize=(16, 8))
    gs = fig.add_gridspec(2, 2, height_ratios=[1, 1.2])

    ax0 = fig.add_subplot(gs[0, :])   # Full-width top row
    ax1 = fig.add_subplot(gs[1, 0])   # Bottom-left
    ax2 = fig.add_subplot(gs[1, 1])   # Bottom-right

    # --- Time-domain stem plot ---
    pos_idx = signal >= 0
    ax0.stem(time_indices[pos_idx], signal[pos_idx],
             basefmt=" ", linefmt='b-', markerfmt='bo')
    neg_idx = signal < 0
    if np.any(neg_idx):
        ax0.stem(time_indices[neg_idx], signal[neg_idx],
                 basefmt=" ", linefmt='r-', markerfmt='ro')

    # ax0.set_xscale("log")
    ax0.set_title(f"Golomb Signal (n = {n}) - Time Domain {dc_status_text}")
    ax0.set_xlabel("Time Index")
    ax0.set_ylabel("Amplitude")
    ax0.grid(True)

    # --- FFT Magnitude Spectrum Plot ---
    ax1.plot(freqs, mag, color='blue')
    #ax1.stem(freqs, mag)
    ax1.set_title(
        f"FFT Magnitude Spectrum{dc_status_text}{window_status_text}")
    ax1.set_xlabel("Frequency (Normalized)")
    ax1.set_ylabel("Magnitude")
    ax1.grid(True)
    ax1.set_xlim(0, 0.5)

    # --- Power Spectrum Plot (Log Scale) ---
    ax2.semilogy(freqs, power, color='blue')
    #ax2.set_yscale('log')
    #ax2.stem(freqs, power)
    ax2.set_title(
        f"Power Spectrum (log scale){dc_status_text}{window_status_text}")
    ax2.set_xlabel("Frequency (Normalized)")
    ax2.set_ylabel("Power")
    ax2.grid(True)
    ax2.set_xlim(0, 0.5)

    plt.tight_layout()
    plt.show()


# Modified to accept windowing parameters
def main(n: int, DC: bool = False, windowing: bool = False, window_type: str = 'hanning'):
    """
    Main function to generate Golomb ruler, create signal, compute spectrum, and plot results.
    DC=False implies remove_dc=True (DC component will be removed from signal).
    DC=True implies remove_dc=False (DC component will be kept in signal).
    windowing=True applies a spectral window; window_type specifies which one.
    """
    remove_dc_flag = not DC  # Determine whether to remove DC based on the DC parameter

    G = golomb_grow(n)
    signal = create_signal_from_golomb(G, remove_dc=remove_dc_flag)
    # Pass windowing parameters to compute_spectrum
    freqs, mag, power = compute_spectrum(signal, windowing, window_type)

    # Pass windowing status and type to plot_results for title annotation
    plot_results(signal, freqs, mag, power, n,
                 remove_dc_flag, windowing, window_type)


# --- Execute the main function ---
if __name__ == "__main__":

    print("\n--- Example 3: DC Removed, Hanning Window Applied ---")
    main(n=17, DC=False, windowing=True, window_type='hanning')

    print("\n--- Example 4: DC Kept, Hanning Window Applied ---")
    main(n=17, DC=True, windowing=True, window_type='hanning')
